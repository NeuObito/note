### 并发编程
- 对象是过程的抽象，线程是调度的抽象。

#### 为什么要并发
- 并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。
- 解耦目的与时机能明显地改进应用程序的吞吐量和结构。

##### 并发的一些说明
- 并发不一定能改进性能，并发只在多个线程或处理器之间能分享大量等待时间的时候管用。
- 编写并发程序会影响原有设计，因为目的与时间的解耦往往对系统结构产生巨大的影响。
- 并发会在性能和编写额外代码上增加一些开销。
- 正确的并发是复杂的，即便对于简单的问题也是如此。
- 并发缺陷并非总能重现。
- 并发常常需要对设计策略进行修改。

#### 并发防御原则
##### 单一权责原则
- 单一权责（SRP）认为，方法/类/组件应当只有一个修改的理由。
- 并发相关代码有自己的开发、修改和调优生命周期。
- 开发相关代码有自己要对付的挑战，和非并发相关代码不同，而且往往更为困难。
- 即便没有周边应用程序增加的负担，写的不好的并发代码可能的出错方式的数量也已经足够具有挑战性。
- 建议：分离并发相关代码与其它代码。

##### 限制数据作用域
- 两个线程修改同一个字段时，可能互相干扰，导致未预期的行为。解决方案就是使用特殊方法将该字段设为保护字段，即在代码中保护一块使用共享对象的临界区。限制临界区的数量很重要。
- 如果更新共享数据的地方越多，就越可能发生以下情况：
- 你会忘记保护一个或者多个临界区-破坏了修改共享数据的代码；
- 得多花力气保证一切都受到有效防护（破坏了DRY原则）；
- 很难找到错误根源，也很难判断错误源。
- 建议：谨记数据封装，严格限制对可能被共享的数据的访问。

##### 使用数据复本
- 避免共享数据的好办法之一就是一开始就避免使用共享数据。
- 另一种方式就是复制对象并以只读方式对待。
- 还有一种情况就是从多个线程收集所有复本的结果，并在单个线程中合并这些结果。

##### 线程应该尽可能的独立
- 让每个线程在自己的世界中存在，不与其它线程共享数据。
- 建议：尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集。
